# -*- mode: org -*-
#+STARTUP: overview
* find cumin in our database


#+begin_example
MATCH (p:Product)
WHERE p.name = 'Ground Cumin'
RETURN p
;
#+end_example

Results:
#+begin_example
#+end_example

* list all nodes and relations


#+begin_example
MATCH (n) RETURN n
;
#+end_example

Results:
#+begin_example
{'n': {'name': 'Yellow Curry with Chicken'}}
{'n': {}}
# ...truncated to 10 for brevity
#+end_example

* list unique node types


#+begin_example
MATCH (n)
RETURN DISTINCT labels(n) AS objectType
ORDER BY objectType
;
#+end_example

Results:
#+begin_example
{'objectType': ['Product']}
{'objectType': ['Recipe']}
#+end_example

* find products with identical names


This reveals that I need to clean up duplicates.

#+begin_example
MATCH (p:Product)
WITH p.name AS productName, COLLECT(p) AS products
WHERE SIZE(products) > 1
RETURN productName, products
;
#+end_example

Results:
#+begin_example
#+end_example

* count duplicates for each product


#+begin_example
MATCH (p:Product)
WITH p.name AS productName, COLLECT(p) AS products
WHERE SIZE(products) > 1
RETURN productName, COUNT(products) AS duplicateCount
;
#+end_example

Results:
#+begin_example
#+end_example

* list all products


#+begin_example
MATCH (p:Product)
RETURN p
;
#+end_example

Results:
#+begin_example
{'p': {}}
# ...truncated to 5 for brevity
#+end_example

* list all products with their urls


#+begin_example
MATCH (p:Product)
WITH p.name AS productName, p.urls AS productUrls
UNWIND productUrls AS url
RETURN productName, url
;
#+end_example

Results:
#+begin_example
# ...truncated to 5 for brevity
#+end_example

* list all product names


#+begin_example
MATCH (p:Product)
RETURN p.name
ORDER BY toLower(p.name)
;
#+end_example

Results:
#+begin_example
{'p.name': None}
# ...truncated to 5 for brevity
#+end_example

* list all relations


#+begin_example
MATCH ()-[r]-()
RETURN DISTINCT type(r) AS relationType
ORDER BY relationType
;
#+end_example

Results:
#+begin_example
{'relationType': 'CONTAINS'}
#+end_example

* WRONG: list relation entities with properties


WRONG: list relations, not just CONTAINS and show relation
properties.

Gotcha!  This is wrong.  Notice we're missing the is-the-same-as relation.

#+begin_example
MATCH ()-[r]-()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName
;
#+end_example

Results:
#+begin_example
{'type': 'CONTAINS', 'propertyName': 'quantity'}
#+end_example

* count products with duplicates


In other words how much work do I have to do to cleanup my data?

#+begin_example
MATCH (p:Product)
WITH p.name AS productName, COUNT(p) AS productCount
WHERE productCount > 1
RETURN COUNT(productCount) AS totalDuplicateProducts
;
#+end_example

Results:
#+begin_example
{'totalDuplicateProducts': 0}
#+end_example

* find ingredients for making Thai Curry


#+begin_example
MATCH (r:Recipe {name: 'Vegan Thai Red Curry'})-[:CONTAINS]->(p:Product)
MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN s.name AS StoreName, COLLECT(DISTINCT p.name) AS Ingredients
;
#+end_example

Results:
#+begin_example
#+end_example

* list products by type


#+begin_example
MATCH (p:Product)-[:PURCHASE_AT]->(s:Store)
RETURN p.name AS ProductName, s.name AS StoreName, p.type as Type
ORDER BY toLower(p.type)
;
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* list products that I've not yet assiged a type to


#+begin_example
MATCH (p:Product)
WHERE p.type IS NULL
RETURN p.name
;
#+end_example

Results:
#+begin_example
{'p.name': None}
#+end_example

* details about product urls


#+begin_example
MATCH (r:Recipe)-[c:CONTAINS]->(p:Product)
WHERE id(p) IS NULL
RETURN r.name AS RecipeName, c.quantity AS Quantity, c.urls AS RecipeUrls
;
#+end_example

Results:
#+begin_example
#+end_example

* list product nodes with properties


#+begin_example
MATCH (n:Product) RETURN n
;
#+end_example

Results:
#+begin_example
{'n': {}}
# ...truncated to 10 for brevity
#+end_example

* WRONG: tally products with associated brands


I can't get this to do what I expect.

#+begin_example
// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand = ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND p.brand <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE exists(p.brand) AND trim(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// Neo.ClientError.Statement.SyntaxError
// The property existence syntax `... exists(variable.property)` is no longer supported. Please use `variable.property IS NOT NULL` instead. (line 3, column 11 (offset: 77))
// "    WHERE exists(p.brand) AND trim(p.brand) <> ''"

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND trim(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(p.brand);
//
// In a WITH/RETURN with DISTINCT or an aggregation, it is not possible to access variables declared before the WITH/RETURN: p (line 5, column 22 (offset: 270))
// "    ORDER BY toLower(p.brand);"

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(p.brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE COALESCE(p.brand, '') <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(p.brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE COALESCE(TRIM(p.brand), '') <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(TRIM(p.brand));

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE COALESCE(p.brand, '') <> '' AND TRIM(p.brand) <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(TRIM(p.brand));

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE NOT (p.brand IS NULL OR TRIM(p.brand) = '')
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(TRIM(p.brand));

// cypher how to filter items whose properties are zero length string

// MATCH (n:Node)
// WHERE ALL(prop IN keys(n) WHERE length(n[prop]) = 0)
// RETURN n;

// MATCH (n:Product)
// WHERE ALL(prop IN keys(n) WHERE length(n[prop]) = 0)
// RETURN n;

MATCH (p:Product)
WHERE p.Brand IS NULL OR p.Brand = ""
RETURN COUNT(p) AS productCount
;
#+end_example

Results:
#+begin_example
{'productCount': 1}
#+end_example

* find products without associated brands


#+begin_example
MATCH (p:Product)
WITH count(p) AS TotalProducts,
     sum(CASE WHEN p.brand IS NOT NULL AND p.brand <> '' THEN 1 ELSE 0 END) AS ProductsWithBrand,
     sum(CASE WHEN p.brand IS NULL OR p.brand = '' THEN 1 ELSE 0 END) AS ProductsWithoutBrand
RETURN TotalProducts, ProductsWithBrand, ProductsWithoutBrand
;
#+end_example

Results:
#+begin_example
{'TotalProducts': 1, 'ProductsWithBrand': 0, 'ProductsWithoutBrand': 1}
#+end_example

* include product brands


#+begin_example
MATCH (p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
ORDER BY toLower(Brand)
;
#+end_example

Results:
#+begin_example
{'ProductName': None, 'Type': None, 'Brand': '', 'AvailableAtStores': []}
# ...truncated to 10 for brevity
#+end_example

* find products with non-alphanumeric names


List products whose names contain non-alphanum sorted randomly to
prevent boredom while cleaning data.

#+begin_example
MATCH (p:Product)
WHERE p.name =~ ".*[^a-zA-Z0-9 ].*"
RETURN p.name AS ProductName
ORDER BY RAND()
;
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* get all product urls


#+begin_example
MATCH (p:Product)
RETURN p.name AS ProductName, p.urls AS URLs
;
#+end_example

Results:
#+begin_example
{'ProductName': None, 'URLs': None}
# ...truncated to 10 for brevity
#+end_example

* WRONG: get non-empty product urls


This is not possible.

WRONG: fetch all urls for all products, but then don't show urls
if product doesn't have any

#+begin_example
MATCH (p:Product)
RETURN p.name AS ProductName, p.urls AS URLs
;
#+end_example

Results:
#+begin_example
{'ProductName': None, 'URLs': None}
# ...truncated to 10 for brevity
#+end_example

* get products with non-empty url lists


#+begin_example
MATCH (p:Product)
WHERE p.urls IS NOT NULL AND SIZE(p.urls) > 0
RETURN p.name AS ProductName, p.urls AS URLs
;
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* list product properties


A product may or may not have any one of these properties.

#+begin_example
MATCH (n:Product)
WITH DISTINCT keys(n) AS propertyNamesList
UNWIND propertyNamesList AS propertyName
RETURN DISTINCT propertyName
ORDER BY toLower(propertyName)
;
#+end_example

Results:
#+begin_example
#+end_example

* list PURCHASE-AT relation properties


#+begin_example
MATCH ()-[r:PURCHASE_AT]->()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT propertyNames
;
#+end_example

Results:
#+begin_example
#+end_example

* list case-insensitive properties for all entities


#+begin_example
MATCH (n)
UNWIND keys(n) AS propertyName
RETURN DISTINCT propertyName
ORDER BY toLower(propertyName)
;
#+end_example

Results:
#+begin_example
{'propertyName': 'name'}
#+end_example

* WRONG: list properties for all entities


Item 'list properties of all entities including relations' fixes this.

#+begin_example
MATCH (n)
UNWIND keys(n) AS propertyName
RETURN DISTINCT propertyName
;
#+end_example

Results:
#+begin_example
{'propertyName': 'name'}
#+end_example

* FIXED: list properties across all entities


Get properties of nodes and then get properties of relation
entities and then aggregate them into one list.

#+begin_example
MATCH (n)
UNWIND keys(n) AS propertyName
RETURN DISTINCT 'Node' AS type, propertyName
ORDER BY type, propertyName

UNION

MATCH ()-[r]-()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName
;
#+end_example

Results:
#+begin_example
{'type': 'Node', 'propertyName': 'name'}
{'type': 'CONTAINS', 'propertyName': 'quantity'}
#+end_example

* find products with stores for each


#+begin_example
MATCH (p:Product)-[:PURCHASE_AT]->(s:Store)
RETURN p.name AS ProductName, s.name AS StoreName, p.type as Type
;
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* find product purchasing info


Where the hell do I buy this crap?

#+begin_example
MATCH (p:Product)
WHERE NOT (p)-[:PURCHASE_AT]->(:Store)
RETURN p.name AS ProductName
ORDER BY toLower(ProductName)
;
#+end_example

Results:
#+begin_example
{'ProductName': None}
#+end_example

* find purchasing info for 10 products


list products that don't have a store associated with them, but
limit to 10

Data cleanup is a pain in the ass and I want to take it in bite
size pieces, so randomize the list to keep me interested and
return just 10 to keep me from being disheartended.

#+begin_example
// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// RETURN product.name AS ProductName
// ORDER BY ProductName
// LIMIT 10;

// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// WITH COLLECT(product) AS randomProducts
// UNWIND randomProducts AS product
// RETURN product.name AS ProductName
// ORDER BY ProductName
// LIMIT 10;

// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// LIMIT 10
// RETURN product.name AS ProductName;

// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// LIMIT 10
// WITH COLLECT(product) AS randomProducts
// UNWIND randomProducts AS product
// ORDER BY product.name
// RETURN product.name AS ProductName;

// works:
MATCH (product:Product)
WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
WITH product
ORDER BY RAND()
LIMIT 10
RETURN product.name AS ProductName
ORDER BY ProductName
;
#+end_example

Results:
#+begin_example
{'ProductName': None}
#+end_example

* list the entity type its assocted with


#+begin_example
MATCH (n)
UNWIND labels(n) AS label
UNWIND keys(n) AS propertyName
RETURN label, propertyName
;
#+end_example

Results:
#+begin_example
{'label': 'Recipe', 'propertyName': 'name'}
# ...truncated to 10 for brevity
#+end_example

* list unique entities


#+begin_example
MATCH (n)
WITH DISTINCT labels(n) AS distinctLabels, keys(n) AS propertyNames
UNWIND distinctLabels AS label
UNWIND propertyNames AS propertyName
RETURN DISTINCT label, propertyName
;
#+end_example

Results:
#+begin_example
{'label': 'Recipe', 'propertyName': 'name'}
#+end_example

* list CONTAINS relationships


This doesn't help in the least bit...the properties are
identical...find a better way.

#+begin_example
MATCH ()-[r:CONTAINS]-()
UNWIND keys(r) AS propertyNames
RETURN type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName
;
#+end_example

Results:
#+begin_example
{'type': 'CONTAINS', 'propertyName': 'quantity'}
{'type': 'CONTAINS', 'propertyName': 'quantity'}
# ...truncated to 5 for brevity
#+end_example

* list unique CONTAINS relationships


#+begin_example
MATCH ()-[r:CONTAINS]-()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName
;
#+end_example

Results:
#+begin_example
{'type': 'CONTAINS', 'propertyName': 'quantity'}
#+end_example

* list products with Google Drive photo urls


This fails
#+begin_example
MATCH (p:Product)
WHERE EXISTS(p.urls) AND ANY(url IN p.urls WHERE url CONTAINS 'google')
RETURN p.name AS ProductName, p.urls AS URLs;
#+end_example

with error
#+begin_example
[mtm@Shane-s-Note:poorclaim(master)]$ cypher-shell -a neo4j://localhost:7687 --file /Users/mtm/pdev/taylormonacelli/anythingflorida/query.cypher
The property existence syntax `... exists(variable.property)` is no longer supported. Please use `variable.property IS NOT NULL` instead. (line 2, column 7 (offset: 24))
"WHERE EXISTS(p.urls) AND ANY(url IN p.urls WHERE url CONTAINS 'google')"
     ^
[mtm@Shane-s-Note:poorclaim(master)]$
#+end_example

#+begin_example
// this works as expected:

MATCH (p:Product)
WHERE p.urls IS NOT NULL AND ANY(url IN p.urls WHERE url CONTAINS 'photos.google.com')
RETURN p.name AS ProductName, p.urls AS URLs
;
#+end_example

Results:
#+begin_example
#+end_example

* FIXED: list relation entities and their properties


FIXED: list relations, not just CONTAINS and show relation
properties

This fixes the item in section: 'WRONG: list relations, not
just CONTAINS and show relation properties'

#+begin_example
MATCH ()-[r]-()
RETURN DISTINCT type(r) AS type,
                CASE WHEN size(keys(r)) > 0 THEN keys(r) ELSE [] END AS propertyNames
ORDER BY type, propertyNames
;
#+end_example

Results:
#+begin_example
{'type': 'CONTAINS', 'propertyNames': ['quantity']}
#+end_example

* identify stores for recipe ingredients


suppose I would like to make a particular recipe, then what stores
do I need to visit?

#+begin_example
MATCH (r:Recipe)
WHERE r.name IN ['Vietnamese Spring Rolls (Gỏi Cuốn)']
WITH r
MATCH (r)-[:CONTAINS]->(p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
WITH p, COLLECT(DISTINCT s) AS stores
RETURN COLLECT(DISTINCT p.name) AS Ingredients,
       [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
ORDER BY [store IN Stores | toLower(store)]
;
#+end_example

Results:
#+begin_example
#+end_example

* find stores for Chicken Teriyaki ingredients


suppose I were to make Chicken Teriyaki, then what stores need I visit
to get products I'd need for it?

#+begin_example
MATCH (r:Recipe {name: 'Chicken Teriyaki Recipe'})-[:CONTAINS]->(p:Product)
MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN s.name AS StoreName, COLLECT(DISTINCT p.name) AS Ingredients
;
#+end_example

Results:
#+begin_example
#+end_example

* streamline shopping for recipes


suppose I would like to make 2 recipes, then what stores do I need
to visit?

#+begin_example
MATCH (r:Recipe)
WHERE r.name IN ['Vietnamese Spring Rolls (Gỏi Cuốn)','Tom Yum Goong']
WITH r
MATCH (r)-[:CONTAINS]->(p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
WITH p, COLLECT(DISTINCT s) AS stores
RETURN COLLECT(DISTINCT p.name) AS Ingredients,
       [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
ORDER BY [store IN Stores | toLower(store)]
;
#+end_example

Results:
#+begin_example
#+end_example

* minimize travel for recipe ingredients


If I would like to make a particular recipe, then what stores do I
need to visit and sort products by stores so I don't have to leave
and return because I didn't realize there were two products from the same store

Also, make sure that if a recipe has an item that is not assigned
to a store by the PURCAHSE_AT relation, then the store field
appears empty as opposed to not seeing the product at all

#+begin_example
MATCH (r:Recipe {name: 'Korean Sesame Noodles'})-[:CONTAINS]->(p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
WITH p, COLLECT(DISTINCT s) AS stores
RETURN COLLECT(DISTINCT p.name) AS Ingredients,
       [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
ORDER BY [store IN Stores | toLower(store)]
;
#+end_example

Results:
#+begin_example
#+end_example

* WRONG: remove duplicate ingredients


WRONG: some recipes point to the same product multiple times by
mistake

This doesn't do what I expect.  Need to spend more time iterating.

#+begin_example
MATCH (r:Recipe)-[:CONTAINS]->(p:Product)
WITH r, COLLECT(p) AS products
WHERE SIZE(products) > 1
RETURN r, products
;
#+end_example

Results:
#+begin_example
#+end_example

* locate products with vegetable types


#+begin_example
MATCH (p:Product)
WHERE toLower(p.type) CONTAINS 'vegetable'
RETURN p.name AS ProductName, p.type AS Type
;
#+end_example

Results:
#+begin_example
#+end_example

* locate products with pea-related types


#+begin_example
MATCH (p:Product)
WHERE toLower(p.type) CONTAINS 'peas'
RETURN p.name AS ProductName, p.type AS Type
;
#+end_example

Results:
#+begin_example
#+end_example

* what recipes call for chicken stock?


I made a recipe that calls for chicken stock but I could only buy
1 qt, but recipe didn't call for 1qt. What other recipe can I make
with the leftovers?

#+begin_example
MATCH (recipe:Recipe)-[:CONTAINS]->(ingredient:Product)
WHERE
  toLower(ingredient.name) CONTAINS 'chicken stock'
RETURN recipe, ingredient
ORDER BY toLower(recipe.name)
;
#+end_example

Results:
#+begin_example
#+end_example

* find recipes that contain either carrots or beans


#+begin_example
MATCH (recipe:Recipe)-[:CONTAINS]->(ingredient:Product)
WHERE
  toLower(ingredient.name) CONTAINS 'carrots' OR
  toLower(ingredient.name) CONTAINS 'beans'
RETURN recipe, ingredient
ORDER BY toLower(recipe.name)
;
#+end_example

Results:
#+begin_example
#+end_example

* which recipe contains products that we're not aware of?


#+begin_example
MATCH (recipe:Recipe)-[contains:CONTAINS]->(product:Product)
WHERE product.name IS NULL
RETURN recipe.name, contains.quantity, product.name
;
#+end_example

Results:
#+begin_example
{'recipe.name': 'Yellow Curry with Chicken', 'contains.quantity': '1 tsp', 'product.name': None}
#+end_example
