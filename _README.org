# -*- mode: org -*-
#+STARTUP: overview
* list all nodes and relations

Not sure what a 'node' means other than that its not a
'relation'...I think.

Either way, i have products, stores...things and 'relations
entities' to connect them.

#+begin_example
MATCH (n) RETURN n;
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* list all products


#+begin_example
MATCH (p:Product)
RETURN p;
#+end_example

Results:
#+begin_example
# ...truncated to 5 for brevity
#+end_example

* list all products

In the realm of cypher, the variable, denoted as 'p' or product,
is a matter of nomenclature flexibility, allowing for usage in
both concise or extensive forms, depending on the intricacies of
the cypher context.

When engaged in protracted cypher queries, brevity in naming may
be favored.

However, when interfacing with the Golang driver and
conveying results, employing more elucidative names, such as
'product,' enhances the readability of the Go code.

#+begin_example
MATCH (product:Product)
RETURN product;
#+end_example

Results:
#+begin_example
# ...truncated to 5 for brevity
#+end_example

* find cumin in my list of products


#+begin_example
MATCH (p:Product)
WHERE p.name = 'Ground Cumin'
RETURN p;
#+end_example

Results:
#+begin_example
#+end_example

* list products and include thier properties


#+begin_example
MATCH (p:Product) RETURN p;
#+end_example

Results:
#+begin_example
# ...truncated to 5 for brevity
#+end_example

* list all product names sorted


#+begin_example
MATCH (p:Product)
RETURN p.name
ORDER BY toLower(p.name);
#+end_example

Results:
#+begin_example
# ...truncated to 5 for brevity
#+end_example

* list all product urls


#+begin_example
MATCH (p:Product)
RETURN p.name AS ProductName, p.urls AS ProductURLs;
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* list unique node types


#+begin_example
MATCH (n)
RETURN DISTINCT labels(n) AS objectType
ORDER BY objectType;
#+end_example

Results:
#+begin_example
#+end_example
[[https://www.google.com/search?q=neo4j+cypher+DISTINCT][cypher DISTINCT]]

[[https://www.google.com/search?q=neo4j+cypher+labels+function][cypher labels()]]

* list products with identical names

This reveals that I need to clean up duplicates. Listing two
instances of the same product name is harmful.

#+begin_example
MATCH (p:Product)
WITH p.name AS productName, COLLECT(p) AS products
WHERE SIZE(products) > 1
RETURN productName, products;
#+end_example

Results:
#+begin_example
#+end_example
[[https://www.google.com/search?q=neo4j+cypher+COLLECT+subquery][cypher COLLECT]]

* count duplicates for each product


#+begin_example
MATCH (p:Product)
WITH p.name AS productName, COLLECT(p) AS products
WHERE SIZE(products) > 1
RETURN productName, COUNT(products) AS duplicateCount;
#+end_example

Results:
#+begin_example
#+end_example

* count products with the same name

In other words how much work do I have to do to cleanup my data?

#+begin_example
MATCH (p:Product)
WITH p.name AS productName, COUNT(p) AS productCount
WHERE productCount > 1
RETURN COUNT(productCount) AS totalDuplicateProducts;
#+end_example

Results:
#+begin_example
{"totalDuplicateProducts": 0}
#+end_example

* list all products with their urls

Each product can have 0 or more urls.

#+begin_example
    for each product
       for each url
          ...
#+end_example

#+begin_example
MATCH (p:Product)
WITH p.name AS productName, p.urls AS productUrls
UNWIND productUrls AS url
RETURN productName, url;
#+end_example

Results:
#+begin_example
# ...truncated to 5 for brevity
#+end_example
[[https://www.google.com/search?q=neo4j+cypher+UNWIND][cypher UNWIND]]

[[https://neo4j.com/docs/cypher-manual/current/clauses/unwind/#unwind-unwinding-a-list][cypher UNWINDing a list]]

* count same-name Product, Store, or Recipe(s)

count entities namely Product, Store or Recipe(s) with the same
name

Ok, so it would be useful too to see what other items have the
same name. Thats probably an error.

#+begin_example
// fail:
// MATCH (n)
// WITH n.name AS name, COUNT(n) AS nCount
// WHERE nCount > 1
// RETURN COUNT(nCount) AS totalDuplicateNs, n as N;

// ok:
MATCH (item)
WITH item.name AS itemName, COUNT(item) AS itemCount
WHERE itemCount > 1
RETURN COUNT(itemCount) AS totalDuplicateItems, COLLECT(itemName) AS duplicateItemNames;
#+end_example

Results:
#+begin_example
{"duplicateItemNames": [], "totalDuplicateItems": 0}
#+end_example

* count same-name Product, Store, or Recipe(s) separately

Entities namely Product, Store or Recipe(s) with the same name as
separate record

Q: Ok, that works great, but now why are the results grouped?

A: this why we need unwind...i think.

#+begin_example
MATCH (item)
WITH item.name AS itemName, COUNT(item) AS itemCount
WHERE itemCount > 1
WITH COUNT(itemCount) AS totalDuplicateItems, COLLECT(itemName) AS duplicateItemNames
UNWIND duplicateItemNames AS duplicateItemName
RETURN totalDuplicateItems, duplicateItemName;
#+end_example

Results:
#+begin_example
#+end_example

* BAD: list relation entities with properties

BAD: list relations, not just CONTAINS and show relation
properties.

Gotcha!  This is wrong.  Notice we're missing the is-the-same-as relation.

#+begin_example
MATCH ()-[r]-()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName;
#+end_example

Results:
#+begin_example
#+end_example

* list all relations


#+begin_example
MATCH ()-[r]-()
RETURN DISTINCT type(r) AS relationType
ORDER BY relationType;
#+end_example

Results:
#+begin_example
#+end_example

* find Vegan Thai Red Curry


#+begin_example
MATCH (r:Recipe {name: 'Vegan Thai Red Curry'})-[:CONTAINS]->(p:Product)
MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN r.name as Recipe, s.name AS Store, COLLECT(DISTINCT p.name) AS ProductNames;
#+end_example

Results:
#+begin_example
#+end_example

* find Thai Red Curry without specifying exact title

Substring matching with CONTAINS. We didn't specify Vegan Thai Red
Curry here.

#+begin_example
MATCH (r:Recipe)-[:CONTAINS]->(p:Product)
WHERE r.name CONTAINS 'Thai Red Curry'
MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN r.name as Recipe, s.name AS Store, COLLECT(DISTINCT p.name) AS ProductNames;
#+end_example

Results:
#+begin_example
#+end_example

* find Thai Curry with regex


#+begin_example
MATCH (r:Recipe)-[:CONTAINS]->(p:Product)
WHERE r.name =~ '.*Thai.*Curry.*'
MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN r.name as Recipe, s.name AS Store, COLLECT(DISTINCT p.name) AS ProductNames;
#+end_example

Results:
#+begin_example
#+end_example

* find Thai Curry using cypher IN [] query format

This returns empty...thats unexpected...

#+begin_example
MATCH (r:Recipe)
WHERE 'Thai' IN [r.name] AND 'Curry' IN [r.name]
RETURN r.name AS Recipe;
#+end_example

Results:
#+begin_example
#+end_example

* find Thai Curry with multiple substings

Why does this return no results?

#+begin_example
MATCH (r:Recipe)-[:CONTAINS]->(p:Product)
WHERE 'Thai' IN r.name AND 'Curry' IN r.name
MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN r.name as Recipe, s.name AS Store, COLLECT(DISTINCT p.name) AS ProductNames;
#+end_example

Results:
#+begin_example
#+end_example

* find Thai Curry with regex case insensitively


#+begin_example
MATCH (r:Recipe)-[:CONTAINS]->(p:Product)
WHERE r.name =~ '(?i).*thai.*curry.*'
MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN r.name as Recipe, s.name AS Store, COLLECT(DISTINCT p.name) AS ProductNames;
#+end_example

Results:
#+begin_example
#+end_example

* search Thai Curry, case-insensitive regex, full details

find Thai Curry with regex case insensitively, output full product
details

We have a map of store to products list. In Go, we can queue the
product list up for each store, then loop over stores to show
products we'd need to purchase for each store.

#+begin_example
MATCH (recipe:Recipe)-[:CONTAINS]->(product:Product)
WHERE recipe.name =~ '(?i).*thai.*curry.*'
MATCH (product)-[:PURCHASE_AT]->(store:Store)
RETURN recipe.name as RecipeName, store.name AS StoreName, COLLECT(DISTINCT product) AS Products;
#+end_example

Results:
#+begin_example
#+end_example

* find recipes with either Thai or Curry


#+begin_example
// ok:
// MATCH (r:Recipe)-[:CONTAINS]->(p:Product)
// WHERE r.name =~ '(?i).*Thai.*|(?i).*Curry.*'
// MATCH (p)-[:PURCHASE_AT]->(s:Store)
// RETURN r.name as Recipe, s.name AS Store, COLLECT(DISTINCT p.name) AS ProductNames;

// better:
MATCH (r:Recipe)-[:CONTAINS]->(p:Product)
WHERE r.name =~ '(?i).*(Thai|Curry).*'
MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN r.name as Recipe, s.name AS Store, COLLECT(DISTINCT p.name) AS ProductNames;
#+end_example

Results:
#+begin_example
#+end_example

* list products by type


#+begin_example
MATCH (p:Product)-[:PURCHASE_AT]->(s:Store)
RETURN p.name AS ProductName, s.name AS Store, p.type as Type
ORDER BY toLower(p.type);
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* list products that I've not yet assiged a type to


#+begin_example
MATCH (p:Product)
WHERE p.type IS NULL
RETURN p.name;
#+end_example

Results:
#+begin_example
#+end_example

* list details about product urls

What the hell is this one...I've forgotten.

#+begin_example
MATCH (r:Recipe)-[c:CONTAINS]->(p:Product)
WHERE id(p) IS NULL
RETURN r.name AS Recipe, c.quantity AS Quantity, c.urls AS RecipeUrls;
#+end_example

Results:
#+begin_example
#+end_example

* BAD: tally products with associated brands

I can't get this to do what I expect.

#+begin_example
// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand = ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND p.brand <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE exists(p.brand) AND trim(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// Neo.ClientError.Statement.SyntaxError
// The property existence syntax `... exists(variable.property)` is no longer supported. Please use `variable.property IS NOT NULL` instead. (line 3, column 11 (offset: 77))
// "    WHERE exists(p.brand) AND trim(p.brand) <> ''"

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND trim(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(p.brand);
//
// In a WITH/RETURN with DISTINCT or an aggregation, it is not possible to access variables declared before the WITH/RETURN: p (line 5, column 22 (offset: 270))
// "    ORDER BY toLower(p.brand);"

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(p.brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE COALESCE(p.brand, '') <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(p.brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE COALESCE(TRIM(p.brand), '') <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(TRIM(p.brand));

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE COALESCE(p.brand, '') <> '' AND TRIM(p.brand) <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(TRIM(p.brand));

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE NOT (p.brand IS NULL OR TRIM(p.brand) = '')
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(TRIM(p.brand));

// cypher how to filter items whose properties are zero length string

// MATCH (n:Node)
// WHERE ALL(prop IN keys(n) WHERE length(n[prop]) = 0)
// RETURN n;

// MATCH (n:Product)
// WHERE ALL(prop IN keys(n) WHERE length(n[prop]) = 0)
// RETURN n;

MATCH (p:Product)
WHERE p.Brand IS NULL OR p.Brand = ""
RETURN COUNT(p) AS productCount;
#+end_example

Results:
#+begin_example
{"productCount": 0}
#+end_example

* find products without associated brands


#+begin_example
MATCH (p:Product)
WITH count(p) AS TotalProducts,
     sum(CASE WHEN p.brand IS NOT NULL AND p.brand <> '' THEN 1 ELSE 0 END) AS ProductsWithBrand,
     sum(CASE WHEN p.brand IS NULL OR p.brand = '' THEN 1 ELSE 0 END) AS ProductsWithoutBrand
RETURN TotalProducts, ProductsWithBrand, ProductsWithoutBrand;
#+end_example

Results:
#+begin_example
{"ProductsWithBrand": 0, "ProductsWithoutBrand": 0, "TotalProducts": 0}
#+end_example

* include product brands


#+begin_example
MATCH (p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
ORDER BY toLower(Brand);
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* find products with non-alphanumeric names

List products whose names contain non-alphanum sorted randomly to
prevent boredom while cleaning data.

#+begin_example
MATCH (p:Product)
WHERE p.name =~ ".*[^a-zA-Z0-9 ].*"
RETURN p.name AS ProductName
ORDER BY RAND();
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* BAD: get non-empty product urls

This is not possible.

BAD: fetch all urls for all products, but then don't show urls
if product doesn't have any.

Don't try to coerece cypher into formatting output, use
golang/python/...to pretty-print as you like.

#+begin_example
MATCH (p:Product)
RETURN p.name AS ProductName, p.urls AS URLs;
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* get products with non-empty url lists


#+begin_example
MATCH (p:Product)
WHERE p.urls IS NOT NULL AND SIZE(p.urls) > 0
RETURN p.name AS ProductName, p.urls AS URLs;
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* Candlenuts...really?  What recipe calls for that?


#+begin_example
// ok:
// MATCH (r:Recipe)-[:CONTAINS]->(p:Product {name: 'Candlenuts'})
// RETURN r.name AS Recipe, r.urls AS RecipeURLs;

// better to use case insensitive:
MATCH (r:Recipe)-[:CONTAINS]->(p:Product)
WHERE p.name =~ '(?i)Candlenuts'
RETURN r.name AS Recipe, r.urls AS RecipeURLs;
#+end_example

Results:
#+begin_example
#+end_example

* list products with at least one url


#+begin_example
MATCH (p:Product)
WHERE size(p.urls) > 0
RETURN p.name AS ProductName, p.urls AS URLs;
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* list product properties

A product may or may not have any one of these properties.

#+begin_example
MATCH (n:Product)
WITH DISTINCT keys(n) AS propertyNamesList
UNWIND propertyNamesList AS propertyName
RETURN DISTINCT propertyName
ORDER BY toLower(propertyName);
#+end_example

Results:
#+begin_example
#+end_example

* list PURCHASE-AT relation properties

Find all the PURCHASE-AT relations and aggreget the list of
properties seen.

#+begin_example
MATCH ()-[r:PURCHASE_AT]->()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT propertyNames;
#+end_example

Results:
#+begin_example
#+end_example

* list case-insensitive properties for all entities


#+begin_example
MATCH (n)
UNWIND keys(n) AS propertyName
RETURN DISTINCT propertyName
ORDER BY toLower(propertyName);
#+end_example

Results:
#+begin_example
#+end_example

* BAD: list properties for all entities

It's good becaues it lists properties for node entities

but

Its bad because it doesn't list properties for relation entities.

[[GOOD: list properties across all entities]] fixes this problem.

#+begin_example
MATCH (n)
UNWIND keys(n) AS propertyName
RETURN DISTINCT propertyName;
#+end_example

Results:
#+begin_example
#+end_example

* GOOD: list properties across all entities

Get properties of nodes and then get properties of relation
entities and then aggregate them into one list.

#+begin_example
MATCH (n)
UNWIND keys(n) AS propertyName
RETURN DISTINCT 'Node' AS type, propertyName
ORDER BY type, propertyName

UNION

MATCH ()-[r]-()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName;
#+end_example

Results:
#+begin_example
#+end_example

* find products with stores for each


#+begin_example
MATCH (p:Product)-[:PURCHASE_AT]->(s:Store)
RETURN p.name AS ProductName, s.name AS Store, p.type as Type;
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* list all products you can purchase at dummy store

These items lack a designated source for purchase.

#+begin_example
MATCH (s:Store { name: "dummy place holder" })-[:PURCHASE_AT]->(p:Product)
RETURN p.name
ORDER BY toLower(p.name);
#+end_example

Results:
#+begin_example
#+end_example
Note the arrow direction here. This query fails to give what we
want see next query.

* list all products you can purchase at dummy store

These items lack a designated source for purchase.

This gives what we expect. Removing the direction allows this to
work as expected.  Ponder this one.

#+begin_example
MATCH (s:Store { name: "dummy place holder" })-[:PURCHASE_AT]-(p:Product)
RETURN p.name
ORDER BY toLower(p.name);
#+end_example

Results:
#+begin_example
#+end_example

* find product purchasing info

Where the hell do I buy this crap? This is list of products that
I've not yet assiged a store with the PURCHASE-AT relation.

#+begin_example
MATCH (p:Product)
WHERE NOT (p)-[:PURCHASE_AT]->(:Store)
RETURN p.name AS ProductName
ORDER BY toLower(ProductName);
#+end_example

Results:
#+begin_example
#+end_example

* dammit this is tedious, how much cleanup remains?

When I check out where to buy stuff, I find lots of things I have
no clue where to get.

Count how many of those mystery product locations I need to figure
out.

#+begin_example
MATCH (p:Product)
WHERE NOT (p)-[:PURCHASE_AT]->(:Store)
RETURN COUNT(p) AS ProductCount;
#+end_example

Results:
#+begin_example
{"ProductCount": 0}
#+end_example

* list count of items not associated with a store


#+begin_example
MATCH (p:Product)
WHERE NOT (p)-[:PURCHASE_AT]->(:Store)
WITH p.name AS ProductName, count(p) AS Count
ORDER BY toLower(ProductName)
WITH COLLECT({ProductName: ProductName, Count: Count}) AS products
UNWIND RANGE(0, SIZE(products)-1) AS ItemNumber
RETURN ItemNumber + 1 AS ItemNumber, products[ItemNumber].ProductName AS ProductName;
#+end_example

Results:
#+begin_example
#+end_example

* BAD: items not associated with a store (count)


#+begin_example
MATCH (p:Product)
WHERE NOT (p)-[:PURCHASE_AT]->(:Store)
WITH p.name AS ProductName, count(p) AS Count
ORDER BY toLower(ProductName)
WITH COLLECT({ProductName: ProductName, Count: Count}) AS products
UNWIND RANGE(0, SIZE(products)-1) AS ItemNumber
RETURN (ItemNumber + 1) + '. ' + products[ItemNumber].ProductName;
#+end_example

Results:
#+begin_example
#+end_example

* find purchasing info for 10 products

list products that don't have a store associated with them, but
limit to 10

Data cleanup is a pain in the ass and I want to take it in bite
size pieces, so randomize the list to keep me interested and
return just 10 to keep me from being disheartended.

#+begin_example
// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// RETURN product.name AS ProductName
// ORDER BY ProductName
// LIMIT 10;

// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// WITH COLLECT(product) AS randomProducts
// UNWIND randomProducts AS product
// RETURN product.name AS ProductName
// ORDER BY ProductName
// LIMIT 10;

// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// LIMIT 10
// RETURN product.name AS ProductName;

// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// LIMIT 10
// WITH COLLECT(product) AS randomProducts
// UNWIND randomProducts AS product
// ORDER BY product.name
// RETURN product.name AS ProductName;

// works:
MATCH (product:Product)
WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
WITH product
ORDER BY RAND()
LIMIT 10
RETURN product.name AS ProductName
ORDER BY ProductName;
#+end_example

Results:
#+begin_example
#+end_example

* BAD: list the entity type the property is assocted with

This is crap.  Results are duplicated.

#+begin_example
MATCH (n)
UNWIND labels(n) AS label
UNWIND keys(n) AS propertyName
RETURN label, propertyName;
#+end_example

Results:
#+begin_example
# ...truncated to 10 for brevity
#+end_example

* GOOD: list the entity type the property is assocted with

Here's how we can add distinct to eliminates duplicates...makes it
not crap.

#+begin_example
MATCH (n)
UNWIND labels(n) AS label
UNWIND keys(n) AS propertyName
RETURN DISTINCT label, propertyName;
#+end_example

Results:
#+begin_example
#+end_example

* list unique entities


#+begin_example
MATCH (n)
WITH DISTINCT labels(n) AS distinctLabels, keys(n) AS propertyNames
UNWIND distinctLabels AS label
UNWIND propertyNames AS propertyName
RETURN DISTINCT label, propertyName;
#+end_example

Results:
#+begin_example
#+end_example

* list CONTAINS relationships

This doesn't help in the least bit...the properties are
identical...find a better way.

#+begin_example
MATCH ()-[r:CONTAINS]-()
UNWIND keys(r) AS propertyNames
RETURN type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName;
#+end_example

Results:
#+begin_example
# ...truncated to 5 for brevity
#+end_example

* list unique CONTAINS relationship properties


#+begin_example
MATCH ()-[r:CONTAINS]-()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName;
#+end_example

Results:
#+begin_example
#+end_example

* list products with Google Drive photo urls

This fails
#+begin_example
MATCH (p:Product)
WHERE EXISTS(p.urls) AND ANY(url IN p.urls WHERE url CONTAINS 'google')
RETURN p.name AS ProductName, p.urls AS URLs;
#+end_example

with error
#+begin_example
[mtm@Shane-s-Note:poorclaim(master)]$ cypher-shell -a neo4j://localhost:7687 --file /Users/mtm/pdev/taylormonacelli/anythingflorida/query.cypher
The property existence syntax `... exists(variable.property)` is no longer supported. Please use `variable.property IS NOT NULL` instead. (line 2, column 7 (offset: 24))
"WHERE EXISTS(p.urls) AND ANY(url IN p.urls WHERE url CONTAINS 'google')"
     ^
[mtm@Shane-s-Note:poorclaim(master)]$
#+end_example

#+begin_example
// this works as expected:

MATCH (p:Product)
WHERE p.urls IS NOT NULL AND ANY(url IN p.urls WHERE url CONTAINS 'photos.google.com')
RETURN p.name AS ProductName, p.urls AS URLs;
#+end_example

Results:
#+begin_example
#+end_example

* GOOD: list relation entities and their properties

GOOD: list relations, not just CONTAINS and show relation
properties

This fixes the item in section: 'BAD: list relations, not
just CONTAINS and show relation properties'

#+begin_example
MATCH ()-[r]-()
RETURN DISTINCT type(r) AS type,
                CASE WHEN size(keys(r)) > 0 THEN keys(r) ELSE [] END AS propertyNames
ORDER BY type, propertyNames;
#+end_example

Results:
#+begin_example
#+end_example

* identify stores for recipe ingredients

suppose I would like to make a particular recipe, then what stores
do I need to visit?

#+begin_example
MATCH (r:Recipe)
WHERE r.name IN ['Vietnamese Spring Rolls (Gỏi Cuốn)']
WITH r
MATCH (r)-[:CONTAINS]->(p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
WITH p, COLLECT(DISTINCT s) AS stores
RETURN COLLECT(DISTINCT p.name) AS Products,
       [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
ORDER BY [store IN Stores | toLower(store)];
#+end_example

Results:
#+begin_example
#+end_example

* find stores for Chicken Teriyaki ingredients

suppose I were to make Chicken Teriyaki, then what stores need I visit
to get products I'd need for it?

#+begin_example
MATCH (r:Recipe {name: 'Chicken Teriyaki Recipe'})-[:CONTAINS]->(p:Product)
MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN s.name AS Store, COLLECT(DISTINCT p.name) AS Products;
#+end_example

Results:
#+begin_example
#+end_example

* streamline shopping for recipes

suppose I would like to make 2 recipes, then what stores do I need
to visit?

#+begin_example
MATCH (r:Recipe)
WHERE r.name IN ['Vietnamese Spring Rolls (Gỏi Cuốn)','Tom Yum Goong']
WITH r
MATCH (r)-[:CONTAINS]->(p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
WITH p, COLLECT(DISTINCT s) AS stores
RETURN COLLECT(DISTINCT p.name) AS Products,
       [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
ORDER BY [store IN Stores | toLower(store)];
#+end_example

Results:
#+begin_example
#+end_example

* minimize travel for recipe ingredients

If I would like to make a particular recipe, then what stores do I
need to visit and sort products by stores so I don't have to leave
and return because I didn't realize there were two products from the same store

Also, make sure that if a recipe has an item that is not assigned
to a store by the PURCAHSE_AT relation, then the store field
appears empty as opposed to not seeing the product at all

#+begin_example
MATCH (r:Recipe {name: 'Korean Sesame Noodles'})-[:CONTAINS]->(p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
WITH p, COLLECT(DISTINCT s) AS stores
RETURN COLLECT(DISTINCT p.name) AS Products,
       [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
ORDER BY [store IN Stores | toLower(store)];
#+end_example

Results:
#+begin_example
#+end_example

* BAD: remove duplicate ingredients

BAD: some recipes point to the same product multiple times by
mistake

This doesn't do what I expect.  Need to spend more time iterating.

#+begin_example
MATCH (r:Recipe)-[:CONTAINS]->(p:Product)
WITH r, COLLECT(p) AS products
WHERE SIZE(products) > 1
RETURN r, products;
#+end_example

Results:
#+begin_example
#+end_example

* locate products with vegetable types


#+begin_example
MATCH (p:Product)
WHERE toLower(p.type) CONTAINS 'vegetable'
RETURN p.name AS ProductName, p.type AS Type;
#+end_example

Results:
#+begin_example
#+end_example

* locate products with pea-related types


#+begin_example
MATCH (p:Product)
WHERE toLower(p.type) CONTAINS 'peas'
RETURN p.name AS ProductName, p.type AS Type;
#+end_example

Results:
#+begin_example
#+end_example

* what recipes call for chicken stock?

I made a recipe that calls for chicken stock but I could only buy
1 qt, but recipe didn't call for 1qt. What other recipe can I make
with the leftovers?

#+begin_example
MATCH (recipe:Recipe)-[:CONTAINS]->(ingredient:Product)
WHERE
  toLower(ingredient.name) CONTAINS 'chicken stock'
RETURN recipe, ingredient
ORDER BY toLower(recipe.name);
#+end_example

Results:
#+begin_example
#+end_example

* recipes that call for chicken stock

Loop over all recipes that call for chicken stock and show their
ingredients.

#+begin_example
MATCH (recipe:Recipe)-[:CONTAINS]->(ingredient:Product)
WHERE toLower(ingredient.name) CONTAINS 'chicken stock'
WITH recipe
MATCH (recipe)-[:CONTAINS]->(allIngredients:Product)
RETURN recipe.name AS Recipe, recipe.urls AS RecipeURLs, COLLECT(DISTINCT allIngredients.name) AS AllIngredients
ORDER BY toLower(recipe.name);
#+end_example

Results:
#+begin_example
#+end_example

* find recipes that contain either carrots or beans


#+begin_example
MATCH (recipe:Recipe)-[:CONTAINS]->(ingredient:Product)
WHERE
  toLower(ingredient.name) CONTAINS 'carrots' OR
  toLower(ingredient.name) CONTAINS 'beans'
RETURN recipe, ingredient
ORDER BY toLower(recipe.name);
#+end_example

Results:
#+begin_example
#+end_example

* detecting unknown products in a recipe

Black Beans has cumin, but we don't have cumin listed in the
database...for example.

#+begin_example
MATCH (recipe)-[:CONTAINS]->(product)
WHERE product.name IS NULL
RETURN recipe.name;
#+end_example

Results:
#+begin_example
#+end_example
We're hoping for empty result list. If the result set is empty,
then I've already cleaned up the data.

* recipe with unknown products


#+begin_example
MATCH (recipe)-[r:CONTAINS]->(product)
WHERE product.name IS NULL
RETURN DISTINCT recipe.name, r.quantity;
#+end_example

Results:
#+begin_example
#+end_example
We're hoping for empty result list. If the result set is empty,
then I've already cleaned up the data.

* cleanup data, find recipes with unknown products

This is data cleanup task.

Find all recipes that have products whose product names are empty
or that the product by mistake doesn't yet exist. Its an error in
the data.

Once you've found the recipes, then list all the products
associated with this recipe.  We will need to compare that list.

#+begin_example
MATCH (recipe)-[:CONTAINS]->(product)
WHERE product.name IS NULL
WITH recipe
MATCH (recipe)-[:CONTAINS]->(allProducts)
RETURN recipe.name AS RecipeName, allProducts.name AS ProductName;
#+end_example

Results:
#+begin_example
#+end_example
We're hoping for empty result list. If the result set is empty,
then I've already cleaned up the data.

* fix data for a single recipe


#+begin_example
MATCH (recipe)-[:CONTAINS]->(product)
WHERE product.name IS NULL AND recipe.name = 'Chicken Thai Red Curry'
WITH recipe
MATCH (recipe)-[:CONTAINS]->(allProducts)
RETURN recipe as RecipeName, allProducts;
#+end_example

Results:
#+begin_example
#+end_example
We're hoping for empty result list. If the result set is empty,
then I've already cleaned up the data.

* find stores for recipe ingredients

If I were to make Crispy Baked Tofu, Roasted Broccoli and Fresh
Spring Rolls, then where would I need to go to get the
ingredients?

#+begin_example
MATCH (store:Store)-[:PURCHASE_AT]-(purchasedProduct:Product)-[:CONTAINS]-(recipe:Recipe)
WHERE recipe.name IN ['Crispy Baked Tofu', 'Roasted Broccoli', 'Fresh Spring Rolls']
WITH DISTINCT recipe.name AS RecipeName, store.name AS StoreName, purchasedProduct.name AS ProductName
RETURN RecipeName, StoreName, ProductName
ORDER BY toLower(StoreName);
#+end_example

Results:
#+begin_example
#+end_example
