- cypher_query: |
    MATCH (p:Product)
    WHERE p.name = 'Ground Cumin'
    RETURN p
  title: find cumin in our database
- cypher_query: |
    MATCH (n) RETURN n
  limit: 10
  title: list all nodes and relations
- cypher_query: |
    MATCH (n)
    RETURN DISTINCT labels(n) AS objectType
    ORDER BY objectType
  title: list unique node types
- comment: |
    This reveals that I need to clean up duplicates.
  cypher_query: |
    MATCH (p:Product)
    WITH p.name AS productName, COLLECT(p) AS products
    WHERE SIZE(products) > 1
    RETURN productName, products
  title: find products with identical names
- cypher_query: |
    MATCH (p:Product)
    WITH p.name AS productName, COLLECT(p) AS products
    WHERE SIZE(products) > 1
    RETURN productName, COUNT(products) AS duplicateCount
  title: count duplicates for each product
- cypher_query: |
    MATCH (p:Product)
    RETURN p
  limit: 5
  title: list all products
- cypher_query: |
    MATCH (p:Product)
    WITH p.name AS productName, p.urls AS productUrls
    UNWIND productUrls AS url
    RETURN productName, url
  limit: 5
  title: list all products with their urls
- cypher_query: |
    MATCH (p:Product)
    RETURN p.name
    ORDER BY toLower(p.name)
  limit: 5
  title: list all product names
- cypher_query: |
    MATCH ()-[r]-()
    RETURN DISTINCT type(r) AS relationType
    ORDER BY relationType
  title: list all relations
- comment: |
    WRONG: list relations, not just CONTAINS and show relation
    properties.

    Gotcha!  This is wrong.  Notice we're missing the is-the-same-as relation.
  cypher_query: |
    MATCH ()-[r]-()
    UNWIND keys(r) AS propertyNames
    RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
    ORDER BY type, propertyName
  title: 'WRONG: list relation entities with properties'
- comment: |
    In other words how much work do I have to do to cleanup my data?
  cypher_query: |
    MATCH (p:Product)
    WITH p.name AS productName, COUNT(p) AS productCount
    WHERE productCount > 1
    RETURN COUNT(productCount) AS totalDuplicateProducts
  title: count products with duplicates
- cypher_query: |
    MATCH (r:Recipe {name: 'Vegan Thai Red Curry'})-[:CONTAINS]->(p:Product)
    MATCH (p)-[:PURCHASE_AT]->(s:Store)
    RETURN s.name AS StoreName, COLLECT(DISTINCT p.name) AS Ingredients
  title: find ingredients for making Thai Curry
- cypher_query: |
    MATCH (p:Product)-[:PURCHASE_AT]->(s:Store)
    RETURN p.name AS ProductName, s.name AS StoreName, p.type as Type
    ORDER BY toLower(p.type)
  limit: 10
  title: list products by type
- cypher_query: |
    MATCH (p:Product)
    WHERE p.type IS NULL
    RETURN p.name
  title: list products that I've not yet assiged a type to
- cypher_query: |
    MATCH (r:Recipe)-[c:CONTAINS]->(p:Product)
    WHERE id(p) IS NULL
    RETURN r.name AS RecipeName, c.quantity AS Quantity, c.urls AS RecipeUrls
  title: details about product urls
- cypher_query: |
    MATCH (n:Product) RETURN n
  limit: 10
  title: list product nodes with properties
- comment: |
    I can't get this to do what I expect.
  cypher_query: |
    // MATCH (p:Product)
    // OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    // WHERE p.brand = ''
    // RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
    // ORDER BY toLower(Brand);

    // MATCH (p:Product)
    // OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    // WHERE p.brand IS NOT NULL AND p.brand <> ''
    // RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
    // ORDER BY toLower(Brand);

    // MATCH (p:Product)
    // OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    // WHERE exists(p.brand) AND trim(p.brand) <> ''
    // RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
    // ORDER BY toLower(Brand);

    // Neo.ClientError.Statement.SyntaxError
    // The property existence syntax `... exists(variable.property)` is no longer supported. Please use `variable.property IS NOT NULL` instead. (line 3, column 11 (offset: 77))
    // "    WHERE exists(p.brand) AND trim(p.brand) <> ''"

    // MATCH (p:Product)
    // OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    // WHERE p.brand IS NOT NULL AND trim(p.brand) <> ''
    // RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
    // ORDER BY toLower(Brand);

    // MATCH (p:Product)
    // OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    // WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
    // RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
    // ORDER BY toLower(Brand);

    // MATCH (p:Product)
    // OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    // WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
    // RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
    // ORDER BY toLower(p.brand);
    //
    // In a WITH/RETURN with DISTINCT or an aggregation, it is not possible to access variables declared before the WITH/RETURN: p (line 5, column 22 (offset: 270))
    // "    ORDER BY toLower(p.brand);"

    // MATCH (p:Product)
    // OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    // WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
    // WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
    // RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
    // ORDER BY toLower(p.brand);

    // MATCH (p:Product)
    // OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    // WHERE COALESCE(p.brand, '') <> ''
    // WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
    // RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
    // ORDER BY toLower(p.brand);

    // MATCH (p:Product)
    // OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    // WHERE COALESCE(TRIM(p.brand), '') <> ''
    // WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
    // RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
    // ORDER BY toLower(TRIM(p.brand));

    // MATCH (p:Product)
    // OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    // WHERE COALESCE(p.brand, '') <> '' AND TRIM(p.brand) <> ''
    // WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
    // RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
    // ORDER BY toLower(TRIM(p.brand));

    // MATCH (p:Product)
    // OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    // WHERE NOT (p.brand IS NULL OR TRIM(p.brand) = '')
    // WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
    // RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
    // ORDER BY toLower(TRIM(p.brand));

    // cypher how to filter items whose properties are zero length string

    // MATCH (n:Node)
    // WHERE ALL(prop IN keys(n) WHERE length(n[prop]) = 0)
    // RETURN n;

    // MATCH (n:Product)
    // WHERE ALL(prop IN keys(n) WHERE length(n[prop]) = 0)
    // RETURN n;

    MATCH (p:Product)
    WHERE p.Brand IS NULL OR p.Brand = ""
    RETURN COUNT(p) AS productCount;
  title: 'WRONG: tally products with associated brands'
- cypher_query: |
    MATCH (p:Product)
    WITH count(p) AS TotalProducts,
         sum(CASE WHEN p.brand IS NOT NULL AND p.brand <> '' THEN 1 ELSE 0 END) AS ProductsWithBrand,
         sum(CASE WHEN p.brand IS NULL OR p.brand = '' THEN 1 ELSE 0 END) AS ProductsWithoutBrand
    RETURN TotalProducts, ProductsWithBrand, ProductsWithoutBrand
  title: find products without associated brands
- cypher_query: |
    MATCH (p:Product)
    OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
    ORDER BY toLower(Brand)
  limit: 10
  title: include product brands
- comment: |
    List products whose names contain non-alphanum sorted randomly to
    prevent boredom while cleaning data.
  cypher_query: |
    MATCH (p:Product)
    WHERE p.name =~ ".*[^a-zA-Z0-9 ].*"
    RETURN p.name AS ProductName
    ORDER BY RAND()
  limit: 10
  title: find products with non-alphanumeric names
- cypher_query: |
    MATCH (p:Product)
    RETURN p.name AS ProductName, p.urls AS URLs;
  limit: 10
  title: get all product urls
- comment: |
    This is not possible.

    WRONG: fetch all urls for all products, but then don't show urls
    if product doesn't have any
  cypher_query: |
    MATCH (p:Product)
    RETURN p.name AS ProductName, p.urls AS URLs;
  limit: 10
  title: 'WRONG: get non-empty product urls'
- cypher_query: |
    MATCH (p:Product)
    WHERE p.urls IS NOT NULL AND SIZE(p.urls) > 0
    RETURN p.name AS ProductName, p.urls AS URLs;
  limit: 10
  title: get products with non-empty url lists
- comment: |
    A product may or may not have any one of these properties.
  cypher_query: |
    MATCH (n:Product)
    WITH DISTINCT keys(n) AS propertyNamesList
    UNWIND propertyNamesList AS propertyName
    RETURN DISTINCT propertyName
    ORDER BY toLower(propertyName)
  title: list product properties
- cypher_query: |
    MATCH ()-[r:PURCHASE_AT]->()
    UNWIND keys(r) AS propertyNames
    RETURN DISTINCT propertyNames
  title: list PURCHASE-AT relation properties
- cypher_query: |
    MATCH (n)
    UNWIND keys(n) AS propertyName
    RETURN DISTINCT propertyName
    ORDER BY toLower(propertyName)
  title: list case-insensitive properties for all entities
- comment: |
    Item 'list properties of all entities including relations' fixes this.
  cypher_query: |
    MATCH (n)
    UNWIND keys(n) AS propertyName
    RETURN DISTINCT propertyName
  title: 'WRONG: list properties for all entities'
- comment: |
    Get properties of nodes and then get properties of relation
    entities and then aggregate them into one list.
  cypher_query: |
    MATCH (n)
    UNWIND keys(n) AS propertyName
    RETURN DISTINCT 'Node' AS type, propertyName
    ORDER BY type, propertyName

    UNION

    MATCH ()-[r]-()
    UNWIND keys(r) AS propertyNames
    RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
    ORDER BY type, propertyName
  title: 'FIXED: list properties across all entities'
- cypher_query: |
    MATCH (p:Product)-[:PURCHASE_AT]->(s:Store)
    RETURN p.name AS ProductName, s.name AS StoreName, p.type as Type
  limit: 10
  title: find products with stores for each
- comment: |
    Where the hell do I buy this crap?
  cypher_query: |
    MATCH (p:Product)
    WHERE NOT (p)-[:PURCHASE_AT]->(:Store)
    RETURN p.name AS ProductName
    ORDER BY toLower(ProductName)
  title: find product purchasing info
- comment: |
    list products that don't have a store associated with them, but
    limit to 10

    Data cleanup is a pain in the ass and I want to take it in bite
    size pieces, so randomize the list to keep me interested and
    return just 10 to keep me from being disheartended.
  cypher_query: |2

    // fail:
    // MATCH (product:Product)
    // WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
    // WITH product
    // ORDER BY RAND()
    // RETURN product.name AS ProductName
    // ORDER BY ProductName
    // LIMIT 10;

    // fail:
    // MATCH (product:Product)
    // WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
    // WITH product
    // ORDER BY RAND()
    // WITH COLLECT(product) AS randomProducts
    // UNWIND randomProducts AS product
    // RETURN product.name AS ProductName
    // ORDER BY ProductName
    // LIMIT 10;

    // fail:
    // MATCH (product:Product)
    // WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
    // WITH product
    // ORDER BY RAND()
    // LIMIT 10
    // RETURN product.name AS ProductName;

    // fail:
    // MATCH (product:Product)
    // WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
    // WITH product
    // ORDER BY RAND()
    // LIMIT 10
    // WITH COLLECT(product) AS randomProducts
    // UNWIND randomProducts AS product
    // ORDER BY product.name
    // RETURN product.name AS ProductName;

    // works:
    MATCH (product:Product)
    WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
    WITH product
    ORDER BY RAND()
    LIMIT 10
    RETURN product.name AS ProductName
    ORDER BY ProductName;
  title: find purchasing info for 10 products
- cypher_query: |
    MATCH (n)
    UNWIND labels(n) AS label
    UNWIND keys(n) AS propertyName
    RETURN label, propertyName
  limit: 10
  title: list the entity type its assocted with
- cypher_query: |
    MATCH (n)
    WITH DISTINCT labels(n) AS distinctLabels, keys(n) AS propertyNames
    UNWIND distinctLabels AS label
    UNWIND propertyNames AS propertyName
    RETURN DISTINCT label, propertyName
  title: list unique entities
- comment: |
    This doesn't help in the least bit...the properties are
    identical...find a better way.
  cypher_query: |
    MATCH ()-[r:CONTAINS]-()
    UNWIND keys(r) AS propertyNames
    RETURN type(r) AS type, propertyNames AS propertyName
    ORDER BY type, propertyName
  limit: 5
  title: list CONTAINS relationships
- cypher_query: |
    MATCH ()-[r:CONTAINS]-()
    UNWIND keys(r) AS propertyNames
    RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
    ORDER BY type, propertyName
  title: list unique CONTAINS relationships
- comment: |
    This fails
    #+begin_example
    MATCH (p:Product)
    WHERE EXISTS(p.urls) AND ANY(url IN p.urls WHERE url CONTAINS 'google')
    RETURN p.name AS ProductName, p.urls AS URLs;
    #+end_example

    with error
    #+begin_example
    [mtm@Shane-s-Note:poorclaim(master)]$ cypher-shell -a neo4j://localhost:7687 --file /Users/mtm/pdev/taylormonacelli/anythingflorida/query.cypher
    The property existence syntax `... exists(variable.property)` is no longer supported. Please use `variable.property IS NOT NULL` instead. (line 2, column 7 (offset: 24))
    "WHERE EXISTS(p.urls) AND ANY(url IN p.urls WHERE url CONTAINS 'google')"
         ^
    [mtm@Shane-s-Note:poorclaim(master)]$
    #+end_example
  cypher_query: |
    // this works as expected:

    MATCH (p:Product)
    WHERE p.urls IS NOT NULL AND ANY(url IN p.urls WHERE url CONTAINS 'photos.google.com')
    RETURN p.name AS ProductName, p.urls AS URLs;
  title: list products with Google Drive photo urls
- comment: |
    FIXED: list relations, not just CONTAINS and show relation
    properties

    This fixes the item in section: 'WRONG: list relations, not
    just CONTAINS and show relation properties'
  cypher_query: |
    MATCH ()-[r]-()
    RETURN DISTINCT type(r) AS type,
                    CASE WHEN size(keys(r)) > 0 THEN keys(r) ELSE [] END AS propertyNames
    ORDER BY type, propertyNames
  title: 'FIXED: list relation entities and their properties'
- comment: |
    suppose I would like to make a particular recipe, then what stores
    do I need to visit?
  cypher_query: |
    MATCH (r:Recipe)
    WHERE r.name IN ['Vietnamese Spring Rolls (Gỏi Cuốn)']
    WITH r
    MATCH (r)-[:CONTAINS]->(p:Product)
    OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    WITH p, COLLECT(DISTINCT s) AS stores
    RETURN COLLECT(DISTINCT p.name) AS Ingredients,
           [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
    ORDER BY [store IN Stores | toLower(store)]
  title: identify stores for recipe ingredients
- comment: |
    suppose I were to make Chicken Teriyaki, then what stores need I visit
    to get products I'd need for it?
  cypher_query: |
    MATCH (r:Recipe {name: 'Chicken Teriyaki Recipe'})-[:CONTAINS]->(p:Product)
    MATCH (p)-[:PURCHASE_AT]->(s:Store)
    RETURN s.name AS StoreName, COLLECT(DISTINCT p.name) AS Ingredients
  title: find stores for Chicken Teriyaki ingredients
- comment: |
    suppose I would like to make 2 recipes, then what stores do I need
    to visit?
  cypher_query: |
    MATCH (r:Recipe)
    WHERE r.name IN ['Vietnamese Spring Rolls (Gỏi Cuốn)','Tom Yum Goong']
    WITH r
    MATCH (r)-[:CONTAINS]->(p:Product)
    OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    WITH p, COLLECT(DISTINCT s) AS stores
    RETURN COLLECT(DISTINCT p.name) AS Ingredients,
           [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
    ORDER BY [store IN Stores | toLower(store)]
  title: streamline shopping for recipes
- comment: |
    If I would like to make a particular recipe, then what stores do I
    need to visit and sort products by stores so I don't have to leave
    and return because I didn't realize there were two products from the same store

    Also, make sure that if a recipe has an item that is not assigned
    to a store by the PURCAHSE_AT relation, then the store field
    appears empty as opposed to not seeing the product at all
  cypher_query: |
    MATCH (r:Recipe {name: 'Korean Sesame Noodles'})-[:CONTAINS]->(p:Product)
    OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
    WITH p, COLLECT(DISTINCT s) AS stores
    RETURN COLLECT(DISTINCT p.name) AS Ingredients,
           [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
    ORDER BY [store IN Stores | toLower(store)]
  title: minimize travel for recipe ingredients
- comment: |
    WRONG: some recipes point to the same product multiple times by
    mistake

    This doesn't do what I expect.  Need to spend more time iterating.
  cypher_query: |
    MATCH (r:Recipe)-[:CONTAINS]->(p:Product)
    WITH r, COLLECT(p) AS products
    WHERE SIZE(products) > 1
    RETURN r, products
  title: 'WRONG: remove duplicate ingredients'
- cypher_query: |
    MATCH (p:Product)
    WHERE toLower(p.type) CONTAINS 'vegetable'
    RETURN p.name AS ProductName, p.type AS Type
  title: locate products with vegetable types
- cypher_query: |
    MATCH (p:Product)
    WHERE toLower(p.type) CONTAINS 'peas'
    RETURN p.name AS ProductName, p.type AS Type
  title: locate products with pea-related types
- cypher_query: |
    MATCH (recipe:Recipe)-[:CONTAINS]->(ingredient:Product)
    WHERE
      toLower(ingredient.name) CONTAINS 'chicken stock'
    RETURN recipe, ingredient
    ORDER BY toLower(recipe.name)
  title: what recipes call for chicken stock?
  comment: |
    I made a recipe that calls for chicken stock but I could only buy
    1 qt, but recipe didn't call for 1qt. What other recipe can I make
    with the leftovers?
- cypher_query: |
    MATCH (recipe:Recipe)-[:CONTAINS]->(ingredient:Product)
    WHERE
      toLower(ingredient.name) CONTAINS 'carrots' OR
      toLower(ingredient.name) CONTAINS 'beans'
    RETURN recipe, ingredient
    ORDER BY toLower(recipe.name)
  title: find recipes that contain either carrots or beans
- cypher_query: |
    MATCH (recipe:Recipe)-[contains:CONTAINS]->(product:Product)
    WHERE product.name IS NULL
    RETURN recipe.name, contains.quantity, product.name
  title: which recipe contains products that we're not aware of?
- cypher_query: |
  title: this should fail, but it silently discards
  comment: |

    How can I get neo4j to fail during data load if the target doesn't
    exist?

    For example when we do this:
    cypher-shell -a neo4j://localhost:7687 --file data.cypher

    and the data.cypher contains this:

    CREATE (drunkenNoodles)-[:CONTAINS { quantity: 'Handful' }]->(basil)

    but basil doesn't exist.

    I want this:
    cypher-shell -a neo4j://localhost:7687 --file data.cypher

    to fail.
