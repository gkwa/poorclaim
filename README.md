I don't know neo4j but it seems like it might be useful.

These snippets were generated by ChatGPT and adapted to my needs.

Don't make me learn graph theory or stare at neo4j documenation for
hours, just give me some examples I can copy/paste.

Later if it turns out using neo4j is doing what I need, then I can
properly pour over the manual to learn what chatgpt did to generate
these snippts.

Please, just give me a shitton of examples that I can
copy/paste...maybe later I'll read the manual.

Data for this is generated from here:
https://github.com/taylormonacelli/anythingflorida/blob/master/data.cypher

in repo:
https://github.com/taylormonacelli/anythingflorida
* [find cumin in our database](#find-cumin-in-our-database)
* [list all nodes and relations](#list-all-nodes-and-relations)
* [list unique node types](#list-unique-node-types)
* [find products with identical names](#find-products-with-identical-names)
* [count duplicates for each product](#count-duplicates-for-each-product)
* [list all products](#list-all-products)
* [list all products with their urls](#list-all-products-with-their-urls)
* [list all product names](#list-all-product-names)
* [list all relations](#list-all-relations)
* [WRONG: list relation entities with properties](#wrong-list-relation-entities-with-properties)
* [count products with duplicates](#count-products-with-duplicates)
* [find ingredients for making Thai Curry](#find-ingredients-for-making-thai-curry)
* [list products by type](#list-products-by-type)
* [list products that I’ve not yet assiged a type to](#list-products-that-ive-not-yet-assiged-a-type-to)
* [details about product urls](#details-about-product-urls)
* [list product nodes with properties](#list-product-nodes-with-properties)
* [WRONG: tally products with associated brands](#wrong-tally-products-with-associated-brands)
* [find products without associated brands](#find-products-without-associated-brands)
* [include product brands](#include-product-brands)
* [find products with non-alphanumeric names](#find-products-with-non-alphanumeric-names)
* [get all product urls](#get-all-product-urls)
* [WRONG: get non-empty product urls](#wrong-get-non-empty-product-urls)
* [get products with non-empty url lists](#get-products-with-non-empty-url-lists)
* [list product properties](#list-product-properties)
* [list PURCHASE-AT relation properties](#list-purchase-at-relation-properties)
* [list case-insensitive properties for all entities](#list-case-insensitive-properties-for-all-entities)
* [WRONG: list properties for all entities](#wrong-list-properties-for-all-entities)
* [FIXED: list properties across all entities](#fixed-list-properties-across-all-entities)
* [find products with stores for each](#find-products-with-stores-for-each)
* [find product purchasing info](#find-product-purchasing-info)
* [find purchasing info for 10 products](#find-purchasing-info-for-10-products)
* [list the entity type its assocted with](#list-the-entity-type-its-assocted-with)
* [list unique entities](#list-unique-entities)
* [list CONTAINS relationships](#list-contains-relationships)
* [list unique CONTAINS relationships](#list-unique-contains-relationships)
* [list products with Google Drive photo urls](#list-products-with-google-drive-photo-urls)
* [FIXED: list relation entities and their properties](#fixed-list-relation-entities-and-their-properties)
* [identify stores for recipe ingredients](#identify-stores-for-recipe-ingredients)
* [find stores for Chicken Teriyaki ingredients](#find-stores-for-chicken-teriyaki-ingredients)
* [streamline shopping for recipes](#streamline-shopping-for-recipes)
* [minimize travel for recipe ingredients](#minimize-travel-for-recipe-ingredients)
* [WRONG: remove duplicate ingredients](#wrong-remove-duplicate-ingredients)
* [locate products with vegetable types](#locate-products-with-vegetable-types)
* [locate products with pea-related types](#locate-products-with-pea-related-types)
* [what recipes call for chicken stock?](#what-recipes-call-for-chicken-stock)
* [find recipes that contain either carrots or beans](#find-recipes-that-contain-either-carrots-or-beans)
* [which recipe contains products that we’re not aware of?](#which-recipe-contains-products-that-were-not-aware-of)
# find cumin in our database

``` example
MATCH (p:Product)
WHERE p.name = 'Ground Cumin'
RETURN p
;
```

Results:

``` example
```

# list all nodes and relations

``` example
MATCH (n) RETURN n
;
```

Results:

``` example
{'n': {'name': 'Yellow Curry with Chicken'}}
{'n': {}}
# ...truncated to 10 for brevity
```

# list unique node types

``` example
MATCH (n)
RETURN DISTINCT labels(n) AS objectType
ORDER BY objectType
;
```

Results:

``` example
{'objectType': ['Product']}
{'objectType': ['Recipe']}
```

# find products with identical names

This reveals that I need to clean up duplicates.

``` example
MATCH (p:Product)
WITH p.name AS productName, COLLECT(p) AS products
WHERE SIZE(products) > 1
RETURN productName, products
;
```

Results:

``` example
```

# count duplicates for each product

``` example
MATCH (p:Product)
WITH p.name AS productName, COLLECT(p) AS products
WHERE SIZE(products) > 1
RETURN productName, COUNT(products) AS duplicateCount
;
```

Results:

``` example
```

# list all products

``` example
MATCH (p:Product)
RETURN p
;
```

Results:

``` example
{'p': {}}
# ...truncated to 5 for brevity
```

# list all products with their urls

``` example
MATCH (p:Product)
WITH p.name AS productName, p.urls AS productUrls
UNWIND productUrls AS url
RETURN productName, url
;
```

Results:

``` example
# ...truncated to 5 for brevity
```

# list all product names

``` example
MATCH (p:Product)
RETURN p.name
ORDER BY toLower(p.name)
;
```

Results:

``` example
{'p.name': None}
# ...truncated to 5 for brevity
```

# list all relations

``` example
MATCH ()-[r]-()
RETURN DISTINCT type(r) AS relationType
ORDER BY relationType
;
```

Results:

``` example
{'relationType': 'CONTAINS'}
```

# WRONG: list relation entities with properties

WRONG: list relations, not just CONTAINS and show relation properties.

Gotcha! This is wrong. Notice we're missing the is-the-same-as relation.

``` example
MATCH ()-[r]-()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName
;
```

Results:

``` example
{'type': 'CONTAINS', 'propertyName': 'quantity'}
```

# count products with duplicates

In other words how much work do I have to do to cleanup my data?

``` example
MATCH (p:Product)
WITH p.name AS productName, COUNT(p) AS productCount
WHERE productCount > 1
RETURN COUNT(productCount) AS totalDuplicateProducts
;
```

Results:

``` example
{'totalDuplicateProducts': 0}
```

# find ingredients for making Thai Curry

``` example
MATCH (r:Recipe {name: 'Vegan Thai Red Curry'})-[:CONTAINS]->(p:Product)
MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN s.name AS StoreName, COLLECT(DISTINCT p.name) AS Ingredients
;
```

Results:

``` example
```

# list products by type

``` example
MATCH (p:Product)-[:PURCHASE_AT]->(s:Store)
RETURN p.name AS ProductName, s.name AS StoreName, p.type as Type
ORDER BY toLower(p.type)
;
```

Results:

``` example
# ...truncated to 10 for brevity
```

# list products that I've not yet assiged a type to

``` example
MATCH (p:Product)
WHERE p.type IS NULL
RETURN p.name
;
```

Results:

``` example
{'p.name': None}
```

# details about product urls

``` example
MATCH (r:Recipe)-[c:CONTAINS]->(p:Product)
WHERE id(p) IS NULL
RETURN r.name AS RecipeName, c.quantity AS Quantity, c.urls AS RecipeUrls
;
```

Results:

``` example
```

# list product nodes with properties

``` example
MATCH (n:Product) RETURN n
;
```

Results:

``` example
{'n': {}}
# ...truncated to 10 for brevity
```

# WRONG: tally products with associated brands

I can't get this to do what I expect.

``` example
// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand = ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND p.brand <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE exists(p.brand) AND trim(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// Neo.ClientError.Statement.SyntaxError
// The property existence syntax `... exists(variable.property)` is no longer supported. Please use `variable.property IS NOT NULL` instead. (line 3, column 11 (offset: 77))
// "    WHERE exists(p.brand) AND trim(p.brand) <> ''"

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND trim(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(Brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
// ORDER BY toLower(p.brand);
//
// In a WITH/RETURN with DISTINCT or an aggregation, it is not possible to access variables declared before the WITH/RETURN: p (line 5, column 22 (offset: 270))
// "    ORDER BY toLower(p.brand);"

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE p.brand IS NOT NULL AND TRIM(p.brand) <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(p.brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE COALESCE(p.brand, '') <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(p.brand);

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE COALESCE(TRIM(p.brand), '') <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(TRIM(p.brand));

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE COALESCE(p.brand, '') <> '' AND TRIM(p.brand) <> ''
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(TRIM(p.brand));

// MATCH (p:Product)
// OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
// WHERE NOT (p.brand IS NULL OR TRIM(p.brand) = '')
// WITH p, COLLECT(DISTINCT s.name) AS AvailableAtStores
// RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, AvailableAtStores
// ORDER BY toLower(TRIM(p.brand));

// cypher how to filter items whose properties are zero length string

// MATCH (n:Node)
// WHERE ALL(prop IN keys(n) WHERE length(n[prop]) = 0)
// RETURN n;

// MATCH (n:Product)
// WHERE ALL(prop IN keys(n) WHERE length(n[prop]) = 0)
// RETURN n;

MATCH (p:Product)
WHERE p.Brand IS NULL OR p.Brand = ""
RETURN COUNT(p) AS productCount
;
```

Results:

``` example
{'productCount': 1}
```

# find products without associated brands

``` example
MATCH (p:Product)
WITH count(p) AS TotalProducts,
     sum(CASE WHEN p.brand IS NOT NULL AND p.brand <> '' THEN 1 ELSE 0 END) AS ProductsWithBrand,
     sum(CASE WHEN p.brand IS NULL OR p.brand = '' THEN 1 ELSE 0 END) AS ProductsWithoutBrand
RETURN TotalProducts, ProductsWithBrand, ProductsWithoutBrand
;
```

Results:

``` example
{'TotalProducts': 1, 'ProductsWithBrand': 0, 'ProductsWithoutBrand': 1}
```

# include product brands

``` example
MATCH (p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN p.name AS ProductName, p.type AS Type, COALESCE(p.brand, '') AS Brand, COLLECT(DISTINCT s.name) AS AvailableAtStores
ORDER BY toLower(Brand)
;
```

Results:

``` example
{'ProductName': None, 'Type': None, 'Brand': '', 'AvailableAtStores': []}
# ...truncated to 10 for brevity
```

# find products with non-alphanumeric names

List products whose names contain non-alphanum sorted randomly to
prevent boredom while cleaning data.

``` example
MATCH (p:Product)
WHERE p.name =~ ".*[^a-zA-Z0-9 ].*"
RETURN p.name AS ProductName
ORDER BY RAND()
;
```

Results:

``` example
# ...truncated to 10 for brevity
```

# get all product urls

``` example
MATCH (p:Product)
RETURN p.name AS ProductName, p.urls AS URLs
;
```

Results:

``` example
{'ProductName': None, 'URLs': None}
# ...truncated to 10 for brevity
```

# WRONG: get non-empty product urls

This is not possible.

WRONG: fetch all urls for all products, but then don't show urls if
product doesn't have any

``` example
MATCH (p:Product)
RETURN p.name AS ProductName, p.urls AS URLs
;
```

Results:

``` example
{'ProductName': None, 'URLs': None}
# ...truncated to 10 for brevity
```

# get products with non-empty url lists

``` example
MATCH (p:Product)
WHERE p.urls IS NOT NULL AND SIZE(p.urls) > 0
RETURN p.name AS ProductName, p.urls AS URLs
;
```

Results:

``` example
# ...truncated to 10 for brevity
```

# list product properties

A product may or may not have any one of these properties.

``` example
MATCH (n:Product)
WITH DISTINCT keys(n) AS propertyNamesList
UNWIND propertyNamesList AS propertyName
RETURN DISTINCT propertyName
ORDER BY toLower(propertyName)
;
```

Results:

``` example
```

# list PURCHASE-AT relation properties

``` example
MATCH ()-[r:PURCHASE_AT]->()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT propertyNames
;
```

Results:

``` example
```

# list case-insensitive properties for all entities

``` example
MATCH (n)
UNWIND keys(n) AS propertyName
RETURN DISTINCT propertyName
ORDER BY toLower(propertyName)
;
```

Results:

``` example
{'propertyName': 'name'}
```

# WRONG: list properties for all entities

Item 'list properties of all entities including relations' fixes this.

``` example
MATCH (n)
UNWIND keys(n) AS propertyName
RETURN DISTINCT propertyName
;
```

Results:

``` example
{'propertyName': 'name'}
```

# FIXED: list properties across all entities

Get properties of nodes and then get properties of relation entities and
then aggregate them into one list.

``` example
MATCH (n)
UNWIND keys(n) AS propertyName
RETURN DISTINCT 'Node' AS type, propertyName
ORDER BY type, propertyName

UNION

MATCH ()-[r]-()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName
;
```

Results:

``` example
{'type': 'Node', 'propertyName': 'name'}
{'type': 'CONTAINS', 'propertyName': 'quantity'}
```

# find products with stores for each

``` example
MATCH (p:Product)-[:PURCHASE_AT]->(s:Store)
RETURN p.name AS ProductName, s.name AS StoreName, p.type as Type
;
```

Results:

``` example
# ...truncated to 10 for brevity
```

# find product purchasing info

Where the hell do I buy this crap?

``` example
MATCH (p:Product)
WHERE NOT (p)-[:PURCHASE_AT]->(:Store)
RETURN p.name AS ProductName
ORDER BY toLower(ProductName)
;
```

Results:

``` example
{'ProductName': None}
```

# find purchasing info for 10 products

list products that don't have a store associated with them, but limit to
10

Data cleanup is a pain in the ass and I want to take it in bite size
pieces, so randomize the list to keep me interested and return just 10
to keep me from being disheartended.

``` example
// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// RETURN product.name AS ProductName
// ORDER BY ProductName
// LIMIT 10;

// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// WITH COLLECT(product) AS randomProducts
// UNWIND randomProducts AS product
// RETURN product.name AS ProductName
// ORDER BY ProductName
// LIMIT 10;

// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// LIMIT 10
// RETURN product.name AS ProductName;

// fail:
// MATCH (product:Product)
// WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
// WITH product
// ORDER BY RAND()
// LIMIT 10
// WITH COLLECT(product) AS randomProducts
// UNWIND randomProducts AS product
// ORDER BY product.name
// RETURN product.name AS ProductName;

// works:
MATCH (product:Product)
WHERE NOT (product)-[:PURCHASE_AT]->(:Store)
WITH product
ORDER BY RAND()
LIMIT 10
RETURN product.name AS ProductName
ORDER BY ProductName
;
```

Results:

``` example
{'ProductName': None}
```

# list the entity type its assocted with

``` example
MATCH (n)
UNWIND labels(n) AS label
UNWIND keys(n) AS propertyName
RETURN label, propertyName
;
```

Results:

``` example
{'label': 'Recipe', 'propertyName': 'name'}
# ...truncated to 10 for brevity
```

# list unique entities

``` example
MATCH (n)
WITH DISTINCT labels(n) AS distinctLabels, keys(n) AS propertyNames
UNWIND distinctLabels AS label
UNWIND propertyNames AS propertyName
RETURN DISTINCT label, propertyName
;
```

Results:

``` example
{'label': 'Recipe', 'propertyName': 'name'}
```

# list CONTAINS relationships

This doesn't help in the least bit…the properties are identical…find a
better way.

``` example
MATCH ()-[r:CONTAINS]-()
UNWIND keys(r) AS propertyNames
RETURN type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName
;
```

Results:

``` example
{'type': 'CONTAINS', 'propertyName': 'quantity'}
{'type': 'CONTAINS', 'propertyName': 'quantity'}
# ...truncated to 5 for brevity
```

# list unique CONTAINS relationships

``` example
MATCH ()-[r:CONTAINS]-()
UNWIND keys(r) AS propertyNames
RETURN DISTINCT type(r) AS type, propertyNames AS propertyName
ORDER BY type, propertyName
;
```

Results:

``` example
{'type': 'CONTAINS', 'propertyName': 'quantity'}
```

# list products with Google Drive photo urls

This fails

``` example
MATCH (p:Product)
WHERE EXISTS(p.urls) AND ANY(url IN p.urls WHERE url CONTAINS 'google')
RETURN p.name AS ProductName, p.urls AS URLs;
```

with error

``` example
[mtm@Shane-s-Note:poorclaim(master)]$ cypher-shell -a neo4j://localhost:7687 --file /Users/mtm/pdev/taylormonacelli/anythingflorida/query.cypher
The property existence syntax `... exists(variable.property)` is no longer supported. Please use `variable.property IS NOT NULL` instead. (line 2, column 7 (offset: 24))
"WHERE EXISTS(p.urls) AND ANY(url IN p.urls WHERE url CONTAINS 'google')"
     ^
[mtm@Shane-s-Note:poorclaim(master)]$
```

``` example
// this works as expected:

MATCH (p:Product)
WHERE p.urls IS NOT NULL AND ANY(url IN p.urls WHERE url CONTAINS 'photos.google.com')
RETURN p.name AS ProductName, p.urls AS URLs
;
```

Results:

``` example
```

# FIXED: list relation entities and their properties

FIXED: list relations, not just CONTAINS and show relation properties

This fixes the item in section: 'WRONG: list relations, not just
CONTAINS and show relation properties'

``` example
MATCH ()-[r]-()
RETURN DISTINCT type(r) AS type,
                CASE WHEN size(keys(r)) > 0 THEN keys(r) ELSE [] END AS propertyNames
ORDER BY type, propertyNames
;
```

Results:

``` example
{'type': 'CONTAINS', 'propertyNames': ['quantity']}
```

# identify stores for recipe ingredients

suppose I would like to make a particular recipe, then what stores do I
need to visit?

``` example
MATCH (r:Recipe)
WHERE r.name IN ['Vietnamese Spring Rolls (Gỏi Cuốn)']
WITH r
MATCH (r)-[:CONTAINS]->(p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
WITH p, COLLECT(DISTINCT s) AS stores
RETURN COLLECT(DISTINCT p.name) AS Ingredients,
       [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
ORDER BY [store IN Stores | toLower(store)]
;
```

Results:

``` example
```

# find stores for Chicken Teriyaki ingredients

suppose I were to make Chicken Teriyaki, then what stores need I visit
to get products I'd need for it?

``` example
MATCH (r:Recipe {name: 'Chicken Teriyaki Recipe'})-[:CONTAINS]->(p:Product)
MATCH (p)-[:PURCHASE_AT]->(s:Store)
RETURN s.name AS StoreName, COLLECT(DISTINCT p.name) AS Ingredients
;
```

Results:

``` example
```

# streamline shopping for recipes

suppose I would like to make 2 recipes, then what stores do I need to
visit?

``` example
MATCH (r:Recipe)
WHERE r.name IN ['Vietnamese Spring Rolls (Gỏi Cuốn)','Tom Yum Goong']
WITH r
MATCH (r)-[:CONTAINS]->(p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
WITH p, COLLECT(DISTINCT s) AS stores
RETURN COLLECT(DISTINCT p.name) AS Ingredients,
       [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
ORDER BY [store IN Stores | toLower(store)]
;
```

Results:

``` example
```

# minimize travel for recipe ingredients

If I would like to make a particular recipe, then what stores do I need
to visit and sort products by stores so I don't have to leave and return
because I didn't realize there were two products from the same store

Also, make sure that if a recipe has an item that is not assigned to a
store by the PURCAHSE<sub>AT</sub> relation, then the store field
appears empty as opposed to not seeing the product at all

``` example
MATCH (r:Recipe {name: 'Korean Sesame Noodles'})-[:CONTAINS]->(p:Product)
OPTIONAL MATCH (p)-[:PURCHASE_AT]->(s:Store)
WITH p, COLLECT(DISTINCT s) AS stores
RETURN COLLECT(DISTINCT p.name) AS Ingredients,
       [store IN stores | CASE WHEN store IS NOT NULL THEN store.name ELSE 'Unknown' END] AS Stores
ORDER BY [store IN Stores | toLower(store)]
;
```

Results:

``` example
```

# WRONG: remove duplicate ingredients

WRONG: some recipes point to the same product multiple times by mistake

This doesn't do what I expect. Need to spend more time iterating.

``` example
MATCH (r:Recipe)-[:CONTAINS]->(p:Product)
WITH r, COLLECT(p) AS products
WHERE SIZE(products) > 1
RETURN r, products
;
```

Results:

``` example
```

# locate products with vegetable types

``` example
MATCH (p:Product)
WHERE toLower(p.type) CONTAINS 'vegetable'
RETURN p.name AS ProductName, p.type AS Type
;
```

Results:

``` example
```

# locate products with pea-related types

``` example
MATCH (p:Product)
WHERE toLower(p.type) CONTAINS 'peas'
RETURN p.name AS ProductName, p.type AS Type
;
```

Results:

``` example
```

# what recipes call for chicken stock?

I made a recipe that calls for chicken stock but I could only buy 1 qt,
but recipe didn't call for 1qt. What other recipe can I make with the
leftovers?

``` example
MATCH (recipe:Recipe)-[:CONTAINS]->(ingredient:Product)
WHERE
  toLower(ingredient.name) CONTAINS 'chicken stock'
RETURN recipe, ingredient
ORDER BY toLower(recipe.name)
;
```

Results:

``` example
```

# find recipes that contain either carrots or beans

``` example
MATCH (recipe:Recipe)-[:CONTAINS]->(ingredient:Product)
WHERE
  toLower(ingredient.name) CONTAINS 'carrots' OR
  toLower(ingredient.name) CONTAINS 'beans'
RETURN recipe, ingredient
ORDER BY toLower(recipe.name)
;
```

Results:

``` example
```

# which recipe contains products that we're not aware of?

``` example
MATCH (recipe:Recipe)-[contains:CONTAINS]->(product:Product)
WHERE product.name IS NULL
RETURN recipe.name, contains.quantity, product.name
;
```

Results:

``` example
{'recipe.name': 'Yellow Curry with Chicken', 'contains.quantity': '1 tsp', 'product.name': None}
```
